{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"client连接aws提示权限错误","text":"解决ssh登录aws报错: UNPROTECTED PRIVATE KEY FILE CSDN参考，已解决","link":"/2021/02/05/client%E8%BF%9E%E6%8E%A5aws%E6%8F%90%E7%A4%BA%E6%9D%83%E9%99%90%E9%94%99%E8%AF%AF/"},{"title":"建博客踩坑笔记","text":"1npm install -g hexo-cli 12hexo init blognpm install hexo-deployer-git --save 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 1npm install --save bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3 hexo-component-inferno@^0.10.5 inferno@^7.3.3 inferno-create-element@^7.3.3 _config.yml设置属性 theme: icarus 部署到gitpage 不显示所有图标把配置文件里，windows文件路径的\\全都换成/ ####hexo g -d免密码更新github page 1234deploy: type: git repo: git@github.com:&lt;用户名&gt;/&lt;用户名&gt;.github.io.git branch: master ####显示pdf方法： 1.安装 post_asset_folder: true 2.输入 data就是路径，长宽自己定 &lt;object data=&quot;./test/test.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;877px&quot;&gt; 连接aws ubuntussh -i username@public_DNS_name","link":"/2021/02/05/%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/"},{"title":"Go学习笔记_基础语法","text":"变量定义名字在前,类型在后,定义完后就有初值,不是nil(初始化为空的是java) Go里的变量声明之后必须用到,不然就会报错 12var a intvar s string 变量赋值 12var a, b int = 3,4var s string = &quot;abc&quot; go可以省略type的名字, 自动推断 1var a,b, c, d = 3,4, true,&quot;def&quot; 更简洁的写法,第一次可以用冒号,之后赋值不能用:=了 1a,b, c, d := 3,4, true,&quot;def&quot; 函数外面也可以定义变量,但不能用 :=, 开头必须用关键字比如var, func等等,这些算包内变量 可以挨个声明,也可以如下一起声明,省略好几个var 12345var( aa=3 ss=&quot;kkk&quot; bb=true) 打印: 1fmt.Println() 内建变量类型 boolean string 有u无符号,没u表示有符号,不规定的话os是多少位,int就是多少位 (u)int (u)int8 (u)int16 (u)int32 (u)int64 uintptr: ptr意思是指针,长度跟随操作系统 byte 8位 rune go语言字符型,用于多国语言等情况,相当于java的char.32位 float32,float64, 必须指定长度,没用float complex64, complex128 复数 int转float必须强制显示地转, go不能隐式类型转换 常量与枚举常量定义go常量不需要大写,大写有别的意思 12const name = &quot;abc&quot;const a,b = 3,4//这里可能是int,可能是float,不确定的,会根据情况自动转 比如c = int(math.Sqrt(a*a+b*b)),sqrt要传float,这里我们可以直接当作float把ab传进去, 枚举类型1234567891011121314151617const( cpp = iota//iota自动自增,比较方便 java _ //自增有的值不要,可以用_跳过 python js)//还可以批量用表达式,iota在这里作为种子const( b = 1 &lt;&lt;(10*iota) kb mb gb tb pb) 条件语句if不需要括号 12345if a != nil { //xxxxx} else { //xxxxxx} 另一种简单写法 1234if &lt;赋值语句&gt;;&lt;判断语句&gt; {} else { } switch默认每个case后都有break, panic用于中断执行并报错 12345678switch op { case &quot;+&quot;: res = a+b case &quot;-&quot; res = a-b default: panic(&quot;error op:&quot;+op)} 另一种写法,switch后面省略了表达式,case后面直接判断即可 12345678switch{ case 条件: xxx case 条件: xxx default: xxx} forgo没有while for后面条件不需要括号 1for &lt;初始条件&gt;; &lt;中止条件&gt;; &lt;操作&gt; 也可以不用分号,相当于别的语言的while 123for scanner.Scan(){ } 什么也不加就死循环 123for { xxxxx} 函数func表示是一个方法 返回值在最后, 可以返回多个值,还能依次给他们起名字 对于调用者,用什么名字没用 123456789101112131415func div(a, b int, op string) (int, int) { return a/b, a%b}//这里return后面不需要指定返回什么,前面已经定义过了//这种赋值方式只能用于很简单的情况,参数多了会造成混乱func div(a, b int, op string) (q, r int) { q = a/b r = a%b return}func main() { q,r := div(13,3)} “_” 的用法如果返回多个变量,我们又只想要其中一个,那我们可以用_取代我们不要的值 1q, _ := div(13,3) 函数式编程函数式编程, 可以理解为方法的返回值是一个方法或方法的指针,(在go里传入参数也可以是一个方法) a:=method(x,y) ,那a就代表一个方法,方法具体是什么由method()返回, 然后我们w = a(3,2)相当于调用了返回的方法 函数式编程的好处是我们可以根据传入method的变量来配置方法,并返回, 然后让其他人来用这个特定的方法 指针go语言指针简单之处在于指针不能直接运算, 比如我们不能拿到个头指针p,然后通过p++读下一个元素 1234var a int = 2var pa *int = &amp;a*pa = 3//此时a=3 值传递/引用传递?go只有一种值传递方式 go使用指针和值传递配合来提升性能 1234567891011//1. 这里变量a和方法f里的a相互独立,改变方法里的a,参数a并不会改变var a intfunc f(a int)//2. f方法传入&amp;a(a的地址), 因此改变pa指向的值,就会改变a,因为他们指向同一个地方var a intfunc f(pa *int)//3. 此处如果Cache里包含一个pData指针指向外部数据,所以即使cache是值传递,里面指针还是都指向同一个地方var cache Cachefunc f(cache Cache) 指针的例子12345678910111213141516171819func swap1(a,b int){ b,a=a,b//这样是不能改变main}func swap2(a,b *int){ *b, *a = *a, *b}func swap3(a,b int)(int, int){ return b,a}func main(){ var a,b = 3,4 swap(a,b)//swap没用 swap2(&amp;a, &amp;b)//有用 a,b = swap3(a,b)} 其他注意要点 go要求对于一个方法传入几个值,换行的时候必须有逗号,不然括号就跟在c后面 12345678func(a, b, c, )func(a, b, c,) go中的nil也可以参与运算","link":"/2021/02/09/Go_2_%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"title":"Go学习笔记_面向对象","text":"面向对象go只支持封装, 不支持继承,多态, 面向接口编程 go没用class, 只有struct 结构体与方法结构创建1234567891011121314151617181920type treeNode struct{ value int left, right *treeNode}func main(){ var root treeNode //创建struct root = treeNode{value:3} root.left = &amp;treeNode{} root.right = &amp;treeNode(5,nil, nil) //**虽然root.right是指针,我们还是可以接着.left,这是go的特性 root.right.left = new(treeNode)//也是新建节点,返回地址 nodes := []treeNode{ {value:3}, {}, {6, nil, &amp;root}, }} 工厂函数用于控制构造struct 这里返回的地址注意是局部变量,但在go中还是可以用的,在C++中就不行 go垃圾回收器自动处理这些变量 123func factory(value int) *treeNode{ return &amp;treeNode{value: value}} 为结构定义方法 在函数名前面的函数,相当于别的语言的this,是接收者 前面括号里的是值传递 node=nil也能调用node的方法,但是使用里面的值时,比如node.value时会报错 1func (node treeNode) setValue()//功能上相当于func print(node treeNode) 也可以前面括号里传入指针,避免拷贝 1func (node *treeNode) setValue(value int) 同样调用root.right.setValue, 前者会产生一个root.right的拷贝,后者会传入root.right的地址. 但是写法上这俩一样 值接收者vs指针接收者 改变内容必须用指针接收者 结构过大也考虑指针接收者 一致性:如果有指针接收者,最好都用指针,避免搞混 包&amp;封装封装 名字一般用CamelCase命名法 首字母大写代表public,小写代表private(public private 针对包来说的) 包 每个目录一个包 main包 有可执行入口,里面有mian函数,一个目录下只能有一个包 为结构定义的方法必须放在一个包, 一个包可以包含不同的文件 扩展已有类型想扩展别人的包: 使用组合1234567891011121314151617type myTreeNode struct{ //我们自建一个struct,然后把别人的struct以指针形式放进来,这样我们就可以扩展tree.Node了 node *tree.Node}func (myNode *myTreeNode)pstOrder(){ if(myNode == nil){ return } left := myTreeNode{myNode.node.left} left.postOrder() right := myTreeNode{myNode.node.right} right.postOrder() myNode.node.Print()//Print是tree.Node自带方法} 定义别名(恩?)1234567891011121314151617Package Queuetype Queue []intfunc (q *Queue) Push(v int) { *q = append(*q, v)}func (q *Queue) Pop() int{ head := (*q)[0] *q = (*q)[1:] return head}func (q *Queue) IsEmpty() bool{ return len(*q) == 0} 12345678910pakcage mainimport{ &quot;xxxx/Queue&quot; &quot;fmt&quot;}func main(){ } 使用内嵌12345678910111213141516type myTreeNode struct{ node *tree.Node}func (myNode *myTreeNode) postOrder() { if(myNode == nil){ return } left := myTreeNode{myNode.node.left} left.postOrder() right := myTreeNode{myNode.node.right} right.postOrder() myNode.node.Print()} 改完后,这里可以把Node的功能全都当作myTreeNode的, 有点像java里的继承 12345678910111213141516171819type myTreeNode struct{ *tree.Node//内嵌Embedding体现在这}func (myNode *myTreeNode) postOrder() { if(myNode == nil ){ return } left := myTreeNode{myNode.Left}//这里不需要myNode.node.left了,直接使用Node的成员变量 right := myTreeNode{myNode.Right} left.postOrder() right.postOrder() myNode.Print()} shadowed method123456//Node本来自己有postOrder,我们在myTreeNode里再定义一个新的postOrder方法,把以前的方法shadow掉了//root.postOrder()此时默认调用shadow方法//此时怎么确保调用到老方法呢?就用root.Node.postOrder()而不是直接root.postOrder()func (myNode *myTreeNode) postOrder { fmt.Println(&quot;shadowed method&quot;)} 下面代码是错误的,说明其实tree.Node和&amp;root就是两种类型,没有联系,前面代码里我们通过embedding方式能运行,算是go语言的语法糖 12var base Root *tree.NodebaseRoot := &amp;root 想要实现子类实现基类,go通过接口来实现","link":"/2021/02/09/Go_4_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"Go学习笔记_内建容器","text":"数组定义定义数组,数量要写在类型前面 123456func main() { var arr1 [5]int arr2 ;= [3]int{1,3,5}//:=必须要给初值 arr3 ;= [...]int{1,3,5,7,9}//必须加..., 不加...在go里有别的含义 var grid [4][5]bool//二维数组,四行五列} 遍历遍历数组,普通方法和使用range 1234567891011for i:= 0; i&lt;len(arr3); i++{ //xxx}for i,v := range arr3{//可以获取坐标i和值v //xxxx}for _,v := range arr3{//只要数值不要下标,就用_代替下标 //xxxx} 值类型 数组是值类型,因此是值传递. 下面方法传入的都是拷贝,改变它的值不会改变原本值. [10]int 和[20]int是不同类型,所以传入参数是数组时数组大小也得对应的上 传入指针可以避免拷贝数组 下面代码必须指定数组大小5,不能省略,省略了数字, 就是切片了 1234567func printArr(arr []int)func printArr(arr [5]int)func main(){ arr ;= [3]int{1,3,5} printArr(&amp;arr)} 切片slicego中切片比数组常用 切片区间左闭右开 slice不是值类型,slice本身没有数据, 它是array的view,能看到array的一部分 123456789101112func main(){ arr := [...]int{0,1,2,3,4,5,6,7} s := arr[2:6] fmt.Println(arr[2:6]) fmt.Println(arr[:6]) fmt.Println(arr[2:]) fmt.Println(arr[:]) }func f1(s []int){ } 可以继续对一个slice进行切片,新切片会在上一个切片基础上进行切割,但他们的值还是对应原数组 12345678arr := [...]int{0,1,2,3,4,5,6,7}s1 := arr[2:6]//对应2 3 4 5s2 := s1[3:5]//5 6,虽然s2切片超过了s1的长度,直接s1[4]会报错,但是用slice可以取得,因为它是顺着array往下数的//数组添加元素s3 := append(s2, 10)//5 6 10, 此时arr: 0,1,2,3,4,5,6,10, 相当于顺着s2,把7换成了10s4 := append(s3, 11)//5 6 10 11,此时arr: 0,1,2,3,4,5,6,10,没变, s3的view的数组不是arr了,而是系统分配的新的更长的数组s5 := append(s4, 12)//5 6 10 11 12 原理 slice里,ptr指向切片开头,len(s1)表示切片长度,直接取值要是超过len,会报错 cap代表从ptr开头到数组末尾的大小,只要不超过底层数组cap(s1)切片就可以向后扩展, slice不能向前扩展 append会导致len和cap改变,如果超过cap, 系统会分配一个新的更大的数组 值传递的缘故,append返回值是新的数组,我们必须要有新的变量去接收 go中切片初值是nil,但是还是可以用,比如可以append 1234567func mian(){ var s []int//切片初值是nil for i:=0; i&lt;100; i++{ s = append(s, 2*i+1)//此处len(s)每次+1; cap每次翻倍 } } make创建固定len和cap的切片,第二个参数是len, 第三个是cap 1234s2 = make(int[], 16)s3 = make(int[], 16, 32) 切片删除元素1234567891011copy(dest, src)//复制slices2[:3]+s2[4:]//删除第三个元素s2 = append(s2[:3],0,0,0)//从index=3开始加三个0s2 = append(s2[:3],s2[4:]...)//从index=3开始,将index=4及往后的元素接上去,记得加上...//删除首,会让len,cap减一(此处还不确定)s2 = s2[1:]//删除尾,只有Len-1s2 = s2[:len(s2)-1] Mapmap声明方式 map声明map[K]V 复合map声明是map[K1]map[K2]V,相当于java里的Map&lt;K1, Map&lt;K2, V&gt;&gt; map map是无序的 使用len获得元素个数 123456789101112131415m := map[string]string { &quot;name&quot;:&quot;xxx&quot;, &quot;age&quot;:&quot;aaa&quot;, &quot;location&quot;:&quot;sqqwq&quot;,}m2 := make(map[string]int) //m2=empty mapvar m3 map[string]int//m3=nilfor k,v := range m{ //xxxxx} 当取map中不存在的值,会得到该类型的zero value 1fmt.Println(m[&quot;age&quot;])//打印map值 如何判断key在不在?根据返回值ok判断 1val, ok = m[&quot;xxx&quot;] 删除元素1delete(m, &quot;key&quot;) key支持的类型 map使用哈希表,必须可以比较相等 除了slice, map, function, 其他内建都可以作为key Struct不包含上面的字段,也能作为key 字符&amp;字符串处理rune 相当于go的char 使用range遍历pos, rune对 使用utf8.RuneCountInString获得字符数量 使用len获得字节长度 使用[]byte获得字节 strings包含很多字符串处理方法的包 Fieds, Split, Join Contains, Index ToLower, ToUpper Trim, TrimLeft, TrimRight","link":"/2021/02/09/Go_3_%E5%86%85%E5%BB%BA%E5%AE%B9%E5%99%A8/"},{"title":"Go学习笔记_依赖管理","text":"go modulego统一管理,用户不需要关心目录结构 go.mod文件:各种用到的库的版本 go.sum文件:所有库+hash,hash保证拉下来的库是对的,没用到的库这里也有 增加依赖: go get 在import里直接写库路径,run的时候自动加载 旧项目迁移到go mod源码不变,只需要改配置 方法: 先go mod init &lt;取个名字&gt; 然后 go build ./...把所有文件build一遍,go会自动拉取库 go install ./...会把所有文件都run一遍 下面方法是老方法,不好用 GOPATH默认在 ~/go(linux) 或者%USERPROFILE%\\go(windows) 大致做法就是, 把所有依赖都放在gopath路径里 gopath下面必须要有src文件夹,所有项目所有代码都要放在里面 GOVENDOR对于不同版本的库,在项目里建一个vendor目录,把当前项目的依赖放在里面,这样即使和外面的版本不一样,默认用本项目的 工具:glid,dep,go dep","link":"/2021/02/09/Go_5_%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"go入门","slug":"go入门","link":"/tags/go%E5%85%A5%E9%97%A8/"},{"name":"hexo踩坑","slug":"hexo踩坑","link":"/tags/hexo%E8%B8%A9%E5%9D%91/"}],"categories":[]}