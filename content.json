{"pages":[{"title":"about","text":"殷凯宇 Kaiyu Yin @wjykyhhh","link":"/about/index.html"},{"title":"","text":"About me 头 殷凯宇 Kaiyu Yin @wjykyhhh 脚","link":"/about/about.html"}],"posts":[{"title":"client连接aws提示权限错误","text":"解决ssh登录aws报错: UNPROTECTED PRIVATE KEY FILE CSDN参考，已解决","link":"/2021/02/05/client%E8%BF%9E%E6%8E%A5aws%E6%8F%90%E7%A4%BA%E6%9D%83%E9%99%90%E9%94%99%E8%AF%AF/"},{"title":"Go学习笔记_基础语法","text":"变量定义名字在前,类型在后,定义完后就有初值,不是nil(初始化为空的是java) Go里的变量声明之后必须用到,不然就会报错 12var a intvar s string 变量赋值 12var a, b int = 3,4var s string = &quot;abc&quot; go可以省略type的名字, 自动推断 1var a,b, c, d = 3,4, true,&quot;def&quot; 更简洁的写法,第一次可以用冒号,之后赋值不能用:=了 1a,b, c, d := 3,4, true,&quot;def&quot; 函数外面也可以定义变量,但不能用 :=, 开头必须用关键字比如var, func等等,这些算包内变量 可以挨个声明,也可以如下一起声明,省略好几个var 12345var( aa=3 ss=&quot;kkk&quot; bb=true) 打印: 1fmt.Println() 内建变量类型 boolean string 有u无符号,没u表示有符号,不规定的话os是多少位,int就是多少位 (u)int (u)int8 (u)int16 (u)int32 (u)int64 uintptr: ptr意思是指针,长度跟随操作系统 byte 8位 rune go语言字符型,用于多国语言等情况,相当于java的char.32位 float32,float64, 必须指定长度,没用float complex64, complex128 复数 int转float必须强制显示地转, go不能隐式类型转换 常量与枚举常量定义go常量不需要大写,大写有别的意思 12const name = &quot;abc&quot;const a,b = 3,4//这里可能是int,可能是float,不确定的,会根据情况自动转 比如c = int(math.Sqrt(a*a+b*b)),sqrt要传float,这里我们可以直接当作float把ab传进去, 枚举类型1234567891011121314151617const( cpp = iota//iota自动自增,比较方便 java _ //自增有的值不要,可以用_跳过 python js)//还可以批量用表达式,iota在这里作为种子const( b = 1 &lt;&lt;(10*iota) kb mb gb tb pb) 条件语句if不需要括号 12345if a != nil { //xxxxx} else { //xxxxxx} 另一种简单写法 1234if &lt;赋值语句&gt;;&lt;判断语句&gt; {} else { } switch默认每个case后都有break, panic用于中断执行并报错 12345678switch op { case &quot;+&quot;: res = a+b case &quot;-&quot; res = a-b default: panic(&quot;error op:&quot;+op)} 另一种写法,switch后面省略了表达式,case后面直接判断即可 12345678switch{ case 条件: xxx case 条件: xxx default: xxx} forgo没有while for后面条件不需要括号 1for &lt;初始条件&gt;; &lt;中止条件&gt;; &lt;操作&gt; 也可以不用分号,相当于别的语言的while 123for scanner.Scan(){ } 什么也不加就死循环 123for { xxxxx} 函数func表示是一个方法 返回值在最后, 可以返回多个值,还能依次给他们起名字 对于调用者,用什么名字没用 123456789101112131415func div(a, b int, op string) (int, int) { return a/b, a%b}//这里return后面不需要指定返回什么,前面已经定义过了//这种赋值方式只能用于很简单的情况,参数多了会造成混乱func div(a, b int, op string) (q, r int) { q = a/b r = a%b return}func main() { q,r := div(13,3)} “_” 的用法如果返回多个变量,我们又只想要其中一个,那我们可以用_取代我们不要的值 1q, _ := div(13,3) 函数式编程函数式编程, 可以理解为方法的返回值是一个方法或方法的指针,(在go里传入参数也可以是一个方法) a:=method(x,y) ,那a就代表一个方法,方法具体是什么由method()返回, 然后我们w = a(3,2)相当于调用了返回的方法 函数式编程的好处是我们可以根据传入method的变量来配置方法,并返回, 然后让其他人来用这个特定的方法 指针go语言指针简单之处在于指针不能直接运算, 比如我们不能拿到个头指针p,然后通过p++读下一个元素 1234var a int = 2var pa *int = &amp;a*pa = 3//此时a=3 值传递/引用传递?go只有一种值传递方式 go使用指针和值传递配合来提升性能 1234567891011//1. 这里变量a和方法f里的a相互独立,改变方法里的a,参数a并不会改变var a intfunc f(a int)//2. f方法传入&amp;a(a的地址), 因此改变pa指向的值,就会改变a,因为他们指向同一个地方var a intfunc f(pa *int)//3. 此处如果Cache里包含一个pData指针指向外部数据,所以即使cache是值传递,里面指针还是都指向同一个地方var cache Cachefunc f(cache Cache) 指针的例子12345678910111213141516171819func swap1(a,b int){ b,a=a,b//这样是不能改变main}func swap2(a,b *int){ *b, *a = *a, *b}func swap3(a,b int)(int, int){ return b,a}func main(){ var a,b = 3,4 swap(a,b)//swap没用 swap2(&amp;a, &amp;b)//有用 a,b = swap3(a,b)} 其他注意要点 go要求对于一个方法传入几个值,换行的时候必须有逗号,不然括号就跟在c后面 12345678func(a, b, c, )func(a, b, c,) go中的nil也可以参与运算","link":"/2021/02/09/Go_2_%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"title":"Go学习笔记_面向对象","text":"面向对象go只支持封装, 不支持继承,多态, 面向接口编程 go没用class, 只有struct 结构体与方法结构创建1234567891011121314151617181920type treeNode struct{ value int left, right *treeNode}func main(){ var root treeNode //创建struct root = treeNode{value:3} root.left = &amp;treeNode{} root.right = &amp;treeNode(5,nil, nil) //**虽然root.right是指针,我们还是可以接着.left,这是go的特性 root.right.left = new(treeNode)//也是新建节点,返回地址 nodes := []treeNode{ {value:3}, {}, {6, nil, &amp;root}, }} 工厂函数用于控制构造struct 这里返回的地址注意是局部变量,但在go中还是可以用的,在C++中就不行 go垃圾回收器自动处理这些变量 123func factory(value int) *treeNode{ return &amp;treeNode{value: value}} 为结构定义方法 在函数名前面的函数,相当于别的语言的this,是接收者 前面括号里的是值传递 node=nil也能调用node的方法,但是使用里面的值时,比如node.value时会报错 1func (node treeNode) setValue()//功能上相当于func print(node treeNode) 也可以前面括号里传入指针,避免拷贝 1func (node *treeNode) setValue(value int) 同样调用root.right.setValue, 前者会产生一个root.right的拷贝,后者会传入root.right的地址. 但是写法上这俩一样 值接收者vs指针接收者 改变内容必须用指针接收者 结构过大也考虑指针接收者 一致性:如果有指针接收者,最好都用指针,避免搞混 包&amp;封装封装 名字一般用CamelCase命名法 首字母大写代表public,小写代表private(public private 针对包来说的) 包 每个目录一个包 main包 有可执行入口,里面有mian函数,一个目录下只能有一个包 为结构定义的方法必须放在一个包, 一个包可以包含不同的文件 扩展已有类型想扩展别人的包: 使用组合1234567891011121314151617type myTreeNode struct{ //我们自建一个struct,然后把别人的struct以指针形式放进来,这样我们就可以扩展tree.Node了 node *tree.Node}func (myNode *myTreeNode)pstOrder(){ if(myNode == nil){ return } left := myTreeNode{myNode.node.left} left.postOrder() right := myTreeNode{myNode.node.right} right.postOrder() myNode.node.Print()//Print是tree.Node自带方法} 定义别名(恩?)1234567891011121314151617Package Queuetype Queue []intfunc (q *Queue) Push(v int) { *q = append(*q, v)}func (q *Queue) Pop() int{ head := (*q)[0] *q = (*q)[1:] return head}func (q *Queue) IsEmpty() bool{ return len(*q) == 0} 12345678910pakcage mainimport{ &quot;xxxx/Queue&quot; &quot;fmt&quot;}func main(){ } 使用内嵌12345678910111213141516type myTreeNode struct{ node *tree.Node}func (myNode *myTreeNode) postOrder() { if(myNode == nil){ return } left := myTreeNode{myNode.node.left} left.postOrder() right := myTreeNode{myNode.node.right} right.postOrder() myNode.node.Print()} 改完后,这里可以把Node的功能全都当作myTreeNode的, 有点像java里的继承 12345678910111213141516171819type myTreeNode struct{ *tree.Node//内嵌Embedding体现在这}func (myNode *myTreeNode) postOrder() { if(myNode == nil ){ return } left := myTreeNode{myNode.Left}//这里不需要myNode.node.left了,直接使用Node的成员变量 right := myTreeNode{myNode.Right} left.postOrder() right.postOrder() myNode.Print()} shadowed method123456//Node本来自己有postOrder,我们在myTreeNode里再定义一个新的postOrder方法,把以前的方法shadow掉了//root.postOrder()此时默认调用shadow方法//此时怎么确保调用到老方法呢?就用root.Node.postOrder()而不是直接root.postOrder()func (myNode *myTreeNode) postOrder { fmt.Println(&quot;shadowed method&quot;)} 下面代码是错误的,说明其实tree.Node和&amp;root就是两种类型,没有联系,前面代码里我们通过embedding方式能运行,算是go语言的语法糖 12var base Root *tree.NodebaseRoot := &amp;root 想要实现子类实现基类,go通过接口来实现","link":"/2021/02/09/Go_4_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"Go学习笔记_内建容器","text":"数组定义定义数组,数量要写在类型前面 123456func main() { var arr1 [5]int arr2 ;= [3]int{1,3,5}//:=必须要给初值 arr3 ;= [...]int{1,3,5,7,9}//必须加..., 不加...在go里有别的含义 var grid [4][5]bool//二维数组,四行五列} 遍历遍历数组,普通方法和使用range 1234567891011for i:= 0; i&lt;len(arr3); i++{ //xxx}for i,v := range arr3{//可以获取坐标i和值v //xxxx}for _,v := range arr3{//只要数值不要下标,就用_代替下标 //xxxx} 值类型 数组是值类型,因此是值传递. 下面方法传入的都是拷贝,改变它的值不会改变原本值. [10]int 和[20]int是不同类型,所以传入参数是数组时数组大小也得对应的上 传入指针可以避免拷贝数组 下面代码必须指定数组大小5,不能省略,省略了数字, 就是切片了 1234567func printArr(arr []int)func printArr(arr [5]int)func main(){ arr ;= [3]int{1,3,5} printArr(&amp;arr)} 切片slicego中切片比数组常用 切片区间左闭右开 slice不是值类型,slice本身没有数据, 它是array的view,能看到array的一部分 123456789101112func main(){ arr := [...]int{0,1,2,3,4,5,6,7} s := arr[2:6] fmt.Println(arr[2:6]) fmt.Println(arr[:6]) fmt.Println(arr[2:]) fmt.Println(arr[:]) }func f1(s []int){ } 可以继续对一个slice进行切片,新切片会在上一个切片基础上进行切割,但他们的值还是对应原数组 12345678arr := [...]int{0,1,2,3,4,5,6,7}s1 := arr[2:6]//对应2 3 4 5s2 := s1[3:5]//5 6,虽然s2切片超过了s1的长度,直接s1[4]会报错,但是用slice可以取得,因为它是顺着array往下数的//数组添加元素s3 := append(s2, 10)//5 6 10, 此时arr: 0,1,2,3,4,5,6,10, 相当于顺着s2,把7换成了10s4 := append(s3, 11)//5 6 10 11,此时arr: 0,1,2,3,4,5,6,10,没变, s3的view的数组不是arr了,而是系统分配的新的更长的数组s5 := append(s4, 12)//5 6 10 11 12 原理 slice里,ptr指向切片开头,len(s1)表示切片长度,直接取值要是超过len,会报错 cap代表从ptr开头到数组末尾的大小,只要不超过底层数组cap(s1)切片就可以向后扩展, slice不能向前扩展 append会导致len和cap改变,如果超过cap, 系统会分配一个新的更大的数组 值传递的缘故,append返回值是新的数组,我们必须要有新的变量去接收 go中切片初值是nil,但是还是可以用,比如可以append 1234567func mian(){ var s []int//切片初值是nil for i:=0; i&lt;100; i++{ s = append(s, 2*i+1)//此处len(s)每次+1; cap每次翻倍 } } make创建固定len和cap的切片,第二个参数是len, 第三个是cap 1234s2 = make(int[], 16)s3 = make(int[], 16, 32) 切片删除元素1234567891011copy(dest, src)//复制slices2[:3]+s2[4:]//删除第三个元素s2 = append(s2[:3],0,0,0)//从index=3开始加三个0s2 = append(s2[:3],s2[4:]...)//从index=3开始,将index=4及往后的元素接上去,记得加上...//删除首,会让len,cap减一(此处还不确定)s2 = s2[1:]//删除尾,只有Len-1s2 = s2[:len(s2)-1] Mapmap声明方式 map声明map[K]V 复合map声明是map[K1]map[K2]V,相当于java里的Map&lt;K1, Map&lt;K2, V&gt;&gt; map map是无序的 使用len获得元素个数 123456789101112131415m := map[string]string { &quot;name&quot;:&quot;xxx&quot;, &quot;age&quot;:&quot;aaa&quot;, &quot;location&quot;:&quot;sqqwq&quot;,}m2 := make(map[string]int) //m2=empty mapvar m3 map[string]int//m3=nilfor k,v := range m{ //xxxxx} 当取map中不存在的值,会得到该类型的zero value 1fmt.Println(m[&quot;age&quot;])//打印map值 如何判断key在不在?根据返回值ok判断 1val, ok = m[&quot;xxx&quot;] 删除元素1delete(m, &quot;key&quot;) key支持的类型 map使用哈希表,必须可以比较相等 除了slice, map, function, 其他内建都可以作为key Struct不包含上面的字段,也能作为key 字符&amp;字符串处理rune 相当于go的char 使用range遍历pos, rune对 使用utf8.RuneCountInString获得字符数量 使用len获得字节长度 使用[]byte获得字节 strings包含很多字符串处理方法的包 Fieds, Split, Join Contains, Index ToLower, ToUpper Trim, TrimLeft, TrimRight","link":"/2021/02/09/Go_3_%E5%86%85%E5%BB%BA%E5%AE%B9%E5%99%A8/"},{"title":"Go学习笔记_依赖管理","text":"go modulego统一管理,用户不需要关心目录结构 go.mod文件:各种用到的库的版本 go.sum文件:所有库+hash,hash保证拉下来的库是对的,没用到的库这里也有 增加依赖: go get 在import里直接写库路径,run的时候自动加载 旧项目迁移到go mod源码不变,只需要改配置 方法: 先go mod init &lt;取个名字&gt; 然后 go build ./...把所有文件build一遍,go会自动拉取库 go install ./...会把所有文件都run一遍 下面方法是老方法,不好用 GOPATH默认在 ~/go(linux) 或者%USERPROFILE%\\go(windows) 大致做法就是, 把所有依赖都放在gopath路径里 gopath下面必须要有src文件夹,所有项目所有代码都要放在里面 GOVENDOR对于不同版本的库,在项目里建一个vendor目录,把当前项目的依赖放在里面,这样即使和外面的版本不一样,默认用本项目的 工具:glid,dep,go dep","link":"/2021/02/10/Go_5_%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"},{"title":"","text":"","link":"/2021/02/10/Untitled/"},{"title":"","text":"goroutinego对并发有通用型支持 Example 123456789101112//并发执行for循环,func mian(){ for i := 0; i &lt; 1000; i++{ go func(i int) { for { fmt.Println(&quot;goroutine %d&quot;,i) } }(i)//这是匿名函数 } time.Sleep(time.milliSecond)}//tip: 虽然goroutine不可抢占,但是print是io操作,io操作涉及协程切换,最终结果还是无序的 go的并发goroutine用到了coroutine协程 轻量级 非抢占式多任务,由协程主动交出控制权(不会被操作系统中断) 编译器/解释器/虚拟机层面的多任务,不是操作系统级别的 多个协程可能在一个或多个线程上运行 123456789101112func mian(){ var a [10]int for i := 0; i &lt; 10; i++{ go func(ii int) { for { a[ii]++ runtime.Gosched()//让当前协程交出控制权 } }(i) } time.Sleep(time.milliSecond)} 进入到文件目录, 下面命令可以看到各协程里面有没有data race 1go run -race xxx.go 协程vs普通函数协程中, 对于main和调用的任务, 控制权是相互的, 而且不一定在同一个线程上 go语言调度器 调度器管理若干线程,每个线程管理若干协程. 任何函数前加上go就可以送给调度器运行 不需要在定义时区分是不是异步函数 协程不可抢占, 调度器会在合适的点(固定点)进行切换 使用-race检测数据访问冲突 goroutine切换点 I/O, select channel 等待锁 函数调用(有时) runtime.Gosched() **(上面的情况仅供参考, 不是百分百切换, 也不是包括了所有情况)","link":"/2021/02/10/Go_10_Goroutine/"},{"title":"","text":"Go _11_Chaneelchannel用于goroutine之间的通信, 是协程之间的双向通道 基本语法1234var c chan int //定义了变量c，但此时是nilc := make(chan int)//这样就能用了c &lt;- 1 //**给c发一个数据1，有发送必须就有接收，不然就会deadlockn := &lt;-c//让n收一个数据， &lt;-c 可以看作一个整体作为变量 channel可以用作参数、返回值 goroutine因为调度，所以协程不一定按照我们调用顺序执行 12345678910111213func demo(c chan int) {}func demo(id int) chan int {} //我们用chan,从外部往chan发数据，所i我们返回值设为chan&lt;-int表达这个意思，让看代码的也能明白//传入方法的类型也得是chan&lt;-int而不是chan int//这时候收数据就不行，不能n&lt;-c了func demo(id int) chan &lt;- int{} Buffered Channel加入缓冲区，这样发送出去的资源，不需要一定等到有协程接收 1c := make(chan int, 3)//缓冲区大小是3 关闭channe，用ok或者range判断结束 发送方可以close，告诉接收方没用数据了。 close之后接收方其实还会一直收到数据，只是收到的是空值，比如int就是收到0，string就是空串 我们可以n, ok := &lt;-c这样既可以通过if !ok判断是不是结束 也可以用for n := range c，这样close之后就会停止接收。注意：如果不close，接收方有range的循环条件不会停 go channel理论基础：CSP模型 不要通过共享内存来通信，通过通信来共享内存 使用Select进行channel调度 select使用 :比如有两个chan,下面代码功能,c1 c2谁先来数据就先走谁 123456789var c1, c2 chan intselect { case n:=&lt;-c1: xxxx case n:= &lt;-c2: xxx default: xxxx} 定时器使用 select中使用nil channel 传统同步机制传统机制都是共享内存, go一般使用channel来同步 waitgroup mutex 123lock sync.Mutex//锁的定义lock.Lock()//加锁lock.Unlock()//去锁 对代码区加锁: 利用方法和defer关键字, 不能像java那样实现 1234func(){ lock.Lock() defer lock.Unlock}() cond","link":"/2021/02/10/Go_11_Channel/"},{"title":"","text":"go的http库 http客户端发送请求 http.Client控制请求头部 httputil简化工作 1234567891011121314151617package mainimport &quot;net/http&quot;func main() { //文档里说每次get完resp得close resp, err:= http.get(&quot;XXXX&quot;) if err != nil{ panic(err) } defer resp.Body.Close() s, err := httputil.DumpResponse(resp, true) //DumpResponse获得resp内容 if err != nil { panic(err) } fmt.Println(&quot;%s&quot;, s)} 自定义http header 1234567891011121314151617181920212223242526272829303132333435package mainimport &quot;net/http&quot;func main() { request, err := http.NewRequest(http.MethodGet, &quot;xxxurl&quot;, nil)//设置request,从而控制http header //浏览器-源码-network-刷新-查看header request.Header.Add(&quot;某个key value&quot;) //clien查看重定向行为 client := http.Client{ CheckRedirect: func( req *http.Request, via []*http.Request) error { fmt.Println(&quot;Redirect:&quot;, req) return nil }, } resp, err:= client.Do(request)//自建client //resp, err:= http.DefaultClient.Do(request)//使用默认client if err != nil{ panic(err) } defer resp.Body.Close() s, err := httputil.DumpResponse(resp, true) //DumpResponse获得resp内容 if err != nil { panic(err) } fmt.Println(&quot;%s&quot;, s)} http服务器性能分析 import_”net/http/pprof” 访问/debug/pprof 使用go tool pprof分析性能 其他标准库 bufio提升读写性能 log encoding/json regexp time strings/math/rand 查看文档方式 自己起服务器查看:命令行输入godoc -http :8888 ,然后浏览器访问本地 locakhost:8888 官方文档 http框架(第三方)gin-gonic/gin12345678910111213141516package mainimport &quot;github.com/gin-gonic/gin&quot;func main() { r := gin.Default()//返回gin engine //访问localhost:8080/ping返回json格式的数据 //同理可以返回各种错误码 r.GET(&quot;/ping&quot;, func(c *gin.Context) { c.JSON(200, gin.H{ &quot;message&quot;: &quot;pong&quot;, }) }) r.Run() // listen and serve on 0.0.0.0:8080 (for windows &quot;localhost:8080&quot;)} middleware使用 无论访问什么地址,都先进middleware再进别的路径, 我们可以利用这个机制记录日志 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package mainimport ( &quot;github.com/gin-gonic/gin&quot; &quot;go.uber.org/zap&quot; &quot;math/rand&quot; &quot;time&quot;)const keyRequestId = &quot;requestId&quot;func main() { r := gin.Default() logger, err := zap.NewProduction() if err != nil { panic(err) } //记录path, response code, log latency //context包含所有关于请求的信息 //Use里可以传入很多方法 r.Use(func(c *gin.Context) { s := time.Now()//开始时间 c.Next() //记录path logger.Info(&quot;incoming request&quot;, zap.String(&quot;path&quot;, c.Request.URL.Path),//path zap.Int(&quot;status&quot;, c.Writer.Status()),//response code zap.Duration(&quot;elapsed&quot;, time.Now().Sub(s)))//latency,开始时间-结束时间 }, func(c *gin.Context) {//设置requestid,在get的时候我们就能获得这个数字 c.Set(keyRequestId, rand.Int()) c.Next() }) r.GET(&quot;/ping&quot;, func(c *gin.Context) { h := gin.H{ &quot;message&quot;: &quot;pong&quot;, } if rid, exists := c.Get(keyRequestId); exists { h[keyRequestId] = rid } c.JSON(200, h) }) r.GET(&quot;/hello&quot;, func(c *gin.Context) { c.String(200, &quot;hello&quot;) }) r.Run()}","link":"/2021/02/10/Go_13_http%E5%8F%8A%E5%85%B6%E5%AE%83%E6%A0%87%E5%87%86%E5%BA%93/"},{"title":"Go学习笔记_函数式编程","text":"函数式编程vs函数指针 参数\\变量\\返回值都可以是函数 高阶函数, 参数也可以是函数, 然后再进行处理 函数-&gt;闭包 函数是编程的严格定义: 不可变性:不能有状态,只有常量和参数 函数只能有参数 go不需要完全满足严格函数式编程的定义 123456789101112131415161718package mainimport &quot;fmt&quot;func adder() func(int) int{ sum :=0 return func(v int) int{ sum+=v return sum }}func main() { a := adder() for i:=0; i&lt;10; i++{ fmt.Println(a(i)) }}//闭包:sum会一直保存,每次调用a(i)就会对保存的sum进行累加,并不会每次调用a就会把sum清0 严格函数式编程的写法,也是实现了累加 1234567891011121314151617type iAdder func(int) (int, iAdder)func adder2(base int) iAdder{ return func(v int) (int, iAdder) { return base+v, adder2(base+v) }}func main(){ a := adder2(0) for( i:=0; i&lt;10; i++) { var s int s, a := a(i) fmt.Println(s) }} Example: fib123456789101112package fib// 1, 1, 2, 3, 5, 8, 13, ...// a b// a bfunc Fibonacci() func() int { a, b := 0, 1 return func() int { a, b = b, a+b return a }} 123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;io&quot; &quot;strings&quot; &quot;imooc.com/ccmouse/learngo/lang/functional/fib&quot;)type intGen func() intfunc (g intGen) Read(p []byte) (n int, err error) { next := g() if next &gt; 10000 { return 0, io.EOF } s := fmt.Sprintf(&quot;%d\\n&quot;, next) // 把next转为string,利用string现成的io接口,把s读到p return strings.NewReader(s).Read(p)}//为方法实现接口(视频7-2)(嗯?)func printFileContents(reader io.Reader) { scanner := bufio.NewScanner(reader) for scanner.Scan() { fmt.Println(scanner.Text()) }}func main() { var f intGen = fib.Fibonacci() printFileContents(f)} Example:二叉树12345678910111213141516171819202122232425package treeimport &quot;fmt&quot;type Node struct { Value int Left, Right *Node}func (node Node) Print() { fmt.Print(node.Value, &quot; &quot;)}func (node *Node) SetValue(value int) { if node == nil { fmt.Println(&quot;Setting Value to nil &quot; + &quot;node. Ignored.&quot;) return } node.Value = value}func CreateNode(value int) *Node { return &amp;Node{Value: value}} 123456789101112131415161718192021222324252627282930313233package treeimport &quot;fmt&quot;func (node *Node) Traverse() { node.TraverseFunc(func(n *Node) { n.Print() }) fmt.Println()}func (node *Node) TraverseFunc(f func(*Node)) { if node == nil { return } node.Left.TraverseFunc(f) f(node) node.Right.TraverseFunc(f)}func (node *Node) TraverseWithChannel() chan *Node { out := make(chan *Node) go func() { node.TraverseFunc(func(node *Node) { out &lt;- node }) close(out) }() return out} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package mainimport ( &quot;fmt&quot; &quot;imooc.com/ccmouse/learngo/lang/tree&quot;)type myTreeNode struct { node *tree.Node}func (myNode *myTreeNode) postOrder() { if myNode == nil || myNode.node == nil { return } left := myTreeNode{myNode.node.Left} right := myTreeNode{myNode.node.Right} left.postOrder() right.postOrder() myNode.node.Print()}func main() { var root tree.Node root = tree.Node{Value: 3} root.Left = &amp;tree.Node{} root.Right = &amp;tree.Node{5, nil, nil} root.Right.Left = new(tree.Node) root.Left.Right = tree.CreateNode(2) root.Right.Left.SetValue(4) fmt.Print(&quot;In-order traversal: &quot;) root.Traverse() fmt.Print(&quot;My own post-order traversal: &quot;) myRoot := myTreeNode{&amp;root} myRoot.postOrder() fmt.Println() nodeCount := 0 root.TraverseFunc(func(node *tree.Node) { nodeCount++ }) fmt.Println(&quot;Node count:&quot;, nodeCount) c := root.TraverseWithChannel() maxNodeValue := 0 for node := range c { if node.Value &gt; maxNodeValue { maxNodeValue = node.Value } } fmt.Println(&quot;Max node value:&quot;, maxNodeValue)}","link":"/2021/02/10/Go_7_%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"title":"Go学习笔记_面向接口","text":"go接口概念*虽然我们声明了接口,但没有地方声明实现了什么接口,这是go的特点 go中继承多态都由接口实现 1234567891011121314func getRetriever() retriver { return infra.Retriever{}}//实现接口, 接口有Get方法type retriever interface { Get(url string) string}func main(){ var r retriever = getRetriever() fmt.Println(r.Get(&quot;xxxx&quot;))} 1 Duck Typing概念go的接口不是java中的接口,虽然是一个名词. 定义并实现接口 go中由使用者来定义接口,实现者只要实现接口里的方法即可 虽然mockretriever.go并没有出现过Retriever这个词但在go中,只要实现了Get方法,就认为实现了Retriever接口. 下面代码real和mock都实现了Get方法,我们可以认为他们都实现了Retriever接口 在main中我们声明r为接口类型, 直接使用它的实现类型即可 retriever.go 1234567891011121314151617181920212223242526272829303132package realimport ( &quot;net/http&quot; &quot;net/http/httputil&quot; &quot;time&quot;)type Retriever struct { UserAgent string TimeOut time.Duration}//指针接收者,避免struct过大,拷贝费资源func (r *Retriever) Get(url string) string { resp, err := http.Get(url) if err != nil { panic(err) } result, err := httputil.DumpResponse(resp, true) resp.Body.Close() if err != nil { panic(err) } return string(result)} mockretriever.go 12345678910111213141516171819202122232425package mockimport &quot;fmt&quot;type Retriever struct { Contents string}func (r *Retriever) Get(url string) string { return r.Contents}func (r *Retriever) String() string { return fmt.Sprintf(&quot;Retriever: {Contents=%s}&quot;, r.Contents)}func (r *Retriever) Post(url string, form map[string]string) string { r.Contents = form[&quot;contents&quot;] return &quot;ok&quot;} main.go//这里main仅供参考,上面代码都改成指针接收者了,这里还是用的值接收 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot; &quot;xxx/mock&quot; &quot;xxx/real&quot;)type Retriever interface { Get(url string) string}const url = &quot;http://www.imooc.com&quot;func download(r Retriever) string { return r.Get(url)}func main() { var r Retriever r = mock.Retriever{&quot;this is mock&quot;} r = real.Retriever{} fmt/Println(download(r))} 接口值类型接口变量里有什么 实现者的类型 实现者的值 / 指针-&gt;实现者 指针接收者只能用指针,值接收者两者都能用 main.go(retriever和mockretriever同上) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package mainimport ( &quot;fmt&quot; &quot;time&quot; &quot;imooc.com/ccmouse/learngo/lang/retriever/mock&quot; &quot;imooc.com/ccmouse/learngo/lang/retriever/real&quot;)type Retriever interface { Get(url string) string}type Poster interface { Post(url string, form map[string]string) string}const url = &quot;http://www.imooc.com&quot;func download(r Retriever) string { return r.Get(url)}func main() { var r Retriever r = mock.Retriever{&quot;this is mock&quot;} fmt.Println(&quot;%T %v\\n&quot;,r,r) r = real.Retriever{} fmt.Println(&quot;%T %v\\n&quot;,r,r) inspect(r) //Type assertion //判断是不是mockretriever if mockRetriever, ok := r.(*mock.Retriever); ok { fmt.Println(mockRetriever.Contents) } else { fmt.Println(&quot;r is not a mock retriever&quot;) } }func inspect(r Retriever) { fmt.Println(&quot;Inspecting&quot;, r) fmt.Printf(&quot; &gt; Type:%T Value:%v\\n&quot;, r, r)//%T是打印类型 fmt.Print(&quot; &gt; Type switch: &quot;) switch v := r.(type) {//获得r里有什么type case *mock.Retriever: fmt.Println(&quot;Contents:&quot;, v.Contents) case *real.Retriever: fmt.Println(&quot;UserAgent:&quot;, v.UserAgent) } fmt.Println()} 限定返回值类型(参考视频6-4末尾) 常用系统接口","link":"/2021/02/10/Go_6_%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3/"},{"title":"Go学习笔记_错误处理与资源管理","text":"defer关键字 defer标记的代码,可以确保调用在函数结束时发生, 也就是return(或者panic)之前 defer是一个先进后出的顺序,类似栈 好处: defer file.close()可以保证文件被关闭,而且不用担心顺序 何时defer Lock/Unlock Open/Close PrintHeader/PrintFooter 错误处理err是什么?err是一个接口,返回类型是string 如果有err,就可以 pathError, ok := err.(*os.PathError) 获得pathError,然后里面可以获得pathError.Op, pathError.Path, pathError.Err等值 12345678file, err := os.Open(&quot;abc.txt&quot;)if err != nil { if pathError, ok := err.(*os.PathError); ok { fmt.Println(pathError.Err) } else { fmt.Println(&quot;unknow err &quot;,err) }} 自建error1err = errors.New(&quot;this is a custom error&quot;) 统一出错处理参考视频8-3 panic 停止当前函数执行 一直向上返回,执行每一层defer 如果没有遇到recover, 程序退出 recover 仅在defer调用中使用 获取panic值 如果无法处理,就重新panic 12345678910111213func trRecover(){ //下面defer的方法可以判断是什么panic然后进行相应操作 defer func(){ r := recover() if err, ok := r.(error); ok { fmt.Println(&quot;Error occurred:&quot;, err) } else { panic(r) } }() }","link":"/2021/02/10/Go_8_%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"title":"Go学习笔记_测试与性能优化","text":"测试传统测试 测试数据和逻辑混在一起 出错信息不明确 一个数据出错,测试全部结束 表格驱动测试(go用的) 分离数据,逻辑 明确的出错信息(直接想怎么打怎么打) 允许部分失败 go语法更容易实践表格驱动测试 测试示例: 123456789101112func TestTriangle(t *testing.T) { tests := [] struct {a,b,c int} { {3,4,5}, {5,12,13}, {3333,4444,5555}, } for _, tt := range tests { if actual := calcTriangle(tt.a, tt.b); actual != tt.c { t.Errorf(&quot;wrong result:%d with %d %d, expect %d&quot;,actual, tt.a, tt.b, tt.c ) } } } 命令行输入go test. 会运行当前目录所有test 代码覆盖率与性能测试go的ide自带覆盖率查看 命令行查看覆盖率 go test运行测试 go test -coverprofile=c.out生成c.out go tool cover会提示c.out怎么用覆盖率, 我们使用 性能测试 用testing.B测试性能 go test -bench .在命令行进行性能测试 pprof性能调优 命令行go test -bench . -cpuprofile cpu.out`生成cpu.out,可以用go tool pprof cpu.out查看性能日志 安装graphviz, 命令行输入web, 生成关于pprof的图,线越粗,时间越久 根据生成结果优化程序 测试http server参考视频9-4, 9-5 生成文档命令行显示文档 1234go docgo doc &lt;包名/方法名&gt;godoc -http :6060//显示所有doc,包括自己的包的文档 下面命令会在go doc生成一个固定格式的doc,诸如此类 1// e.g q.push() 示例代码生成test文件,写example代码,把输出结果作为注释加在代码下 编译会自动检测结果是否相符 godoc自动生成测试example的代码和结果","link":"/2021/02/10/Go_9_%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"},{"title":"Hexo踩坑笔记","text":"##建立hexo博客过程 新建文件夹,安装hexo-cli 1npm install -g hexo-cli 初始化hexo,此处blog可以换成别的想要的名字 12hexo init blog 进入初始化的/blog文件夹, 从icarus 克隆主题仓库,其他主题同理 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 然后进入hexo根目录找到_config.yml, /在最下面,设置theme的值为icarus(注意yaml语法,冒号后一定要加一个空格) 自动安装npm依赖(暂时不懂有什么用) 1npm install 安装插件,部署到github page时需要 1npm install hexo-deployer-git --save 清理, 生成, 启动c: cleang:generates:server 123hexo chexo dhexo s 启动时icarus主题可能会缺少依赖,我的提示我装以下依赖 1npm install --save bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3 hexo-component-inferno@^0.10.5 inferno@^7.3.3 inferno-create-element@^7.3.3 _config.yml设置属性 theme: icarus 部署到gitpage 不显示所有图标把配置文件里，windows文件路径的\\全都换成/ ####hexo g -d免密码更新github page 1234deploy: type: git repo: git@github.com:&lt;用户名&gt;/&lt;用户名&gt;.github.io.git branch: master ####显示pdf方法： 1.安装 post_asset_folder: true 2.输入 data就是路径，长宽自己定 &lt;object data=&quot;./test/test.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;877px&quot;&gt; 连接aws ubuntussh -i username@public_DNS_name","link":"/2021/02/05/Hexo%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/"},{"title":"Typora常用快捷键","text":"把实时渲染打开,修改会很方便 windows快捷键：无序列表：输入-之后输入空格有序列表：输入数字+“.”之后输入空格任务列表：-[空格]空格 文字标题：ctrl+数字表格：ctrl+t生成目录：[TOC]按回车选中一整行：ctrl+l选中单词：ctrl+d选中相同格式的文字：ctrl+e跳转到文章开头：ctrl+home跳转到文章结尾：ctrl+end搜索：ctrl+f替换：ctrl+h引用：输入&gt;之后输入空格代码块：ctrl+alt+f加粗：ctrl+b倾斜：ctrl+i下划线：ctrl+u删除线：alt+shift+5插入图片：直接拖动到指定位置即可或者ctrl+shift+i插入链接：ctrl + k给代码块设置快捷键:#偏好设置-&gt;打开高级设置-&gt;conf.user.json文件 “keyBinding”: { // for example: // “Always on Top”: “Ctrl+Shift+P” “Always on Top”: “Ctrl+Shift+P”, “Code Fences”: “Ctrl+Shift+F”, “Ordered List”:”Ctrl+Alt+o”, “Unordered List”: “Ctrl+Alt+u” },Code Fences 代码块 Ordered List 数字有序列表 Unordered List 无序列表 Mac中的快捷键最大标题：command + 1 或者：#大标题：command + 2 或者：##标准标题：command + 3 或者：###中标题：command + 4 或者：####小标题：command + 5 或者：#####插入表格：command + T插入代码：command + alt +c行间公式 command + Alt + b段落：command + 0竖线 ： command + Alt +q有序列表（1. 2.） ：输入数字+“.”之后输入空格 或者：command + Alt + o黑点标记：command + Alt + u隔离线shift + command + -超链接：command + Alt + l插入链接：command +k下划线：command +u加粗：command +b搜索：command +f","link":"/2021/02/03/Typora%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"title":"Markdown语法","text":"标题（Headings）要创建标题，请在单词或短语前面添加井号 (#) 。井号的数量代表了标题的级别。例如，添加三个井号即创建一个三级标题 (&lt;h3&gt;) (例如：### My Header)。 Markdown HTML 渲染效果 # Heading level 1 &lt;h1&gt;Heading level 1&lt;/h1&gt; Heading level 1 ## Heading level 2 &lt;h2&gt;Heading level 2&lt;/h2&gt; Heading level 2 ### Heading level 3 &lt;h3&gt;Heading level 3&lt;/h3&gt; Heading level 3 #### Heading level 4 &lt;h4&gt;Heading level 4&lt;/h4&gt; Heading level 4 ##### Heading level 5 &lt;h5&gt;Heading level 5&lt;/h5&gt; Heading level 5 ###### Heading level 6 &lt;h6&gt;Heading level 6&lt;/h6&gt; Heading level 6 可选语法还可以在文本下方添加任意数量的 == 号来标识一级标题，或者 -- 号来标识二级标题。 Markdown HTML 渲染效果 Heading level 1=============== &lt;h1&gt;Heading level 1&lt;/h1&gt; Heading level 1 Heading level 2--------------- &lt;h2&gt;Heading level 2&lt;/h2&gt; Heading level 2 标题（Heading）用法的最佳实践当井号（#）和标题文本之间没有空格时，各 Markdown 应用程序的处理方式是不一样的。为了兼容考虑，请在井号和标题文本之间添加一个空格。 ✅ 这样做 ❌ 不要这样做 # Here's a Heading #Here's a Heading 段落（Paragraphs）要创建段落，请使用空白行将一行或多行文本进行分隔。 Markdown HTML 渲染效果 I really like using Markdown.I think I'll use it to format all of my documents from now on. &lt;p&gt;I really like using Markdown.&lt;/p&gt;&lt;p&gt;I think I'll use it to format all of my documents from now on.&lt;/p&gt; I really like using Markdown.I think I’ll use it to format all of my documents from now on. 段落（Paragraph）用法的最佳实践除非 段落在列表中，否则不要用空格（spaces）或制表符（ tabs）缩进段落。 ✅ 这样做 ❌ 不要这样做 Don't put tabs or spaces in front of your paragraphs.Keep lines left-aligned like this. This can result in unexpected formatting problems. Don't add tabs or spaces in front of paragraphs. 换行（Line Breaks）在一行的末尾添加两个或多个空格，然后按回车键（return），即可创建一个换行（line break） (&lt;br&gt;)。 Markdown HTML 渲染效果 This is the first line. And this is the second line. &lt;p&gt;This is the first line.&lt;br&gt;And this is the second line.&lt;/p&gt; This is the first line. And this is the second line. 换行（Line Break）用法的最佳实践几乎每个 Markdown 应用程序都支持两个或多个空格进行换行 (称为 “结尾空格（trailing whitespace）”) 的方式，但这是有争议的，因为很难在编辑器中直接看到空格，并且很多人在每个句子后面都会有意或无意地添加两个空格。由于这个原因，你可能需要使用除结尾空格以外的其它方式来进行换行。幸运的是，几乎每个 Markdown 应用程序都支持另一种换行方式：HTML 的 &lt;br&gt; 标签。 为了兼容性，请在行尾添加“结尾空格”或 HTML 的 &lt;br&gt; 标签来实现换行。 还有两种其他方式我并不推荐使用。CommonMark 和其它几种轻量级标记语言支持在行尾添加反斜杠 (\\) 的方式实现换行，但是并非所有 Markdown 应用程序都支持此种方式，因此从兼容性的角度来看，不推荐使用。并且至少有两种轻量级标记语言支持无须在行尾添加任何内容，只须键入回车键（ return）即可实现换行。 ✅ 这样做 ❌ 不要这样做 First line with two spaces after. And the next line.First line with the HTML tag after.&lt;br&gt;And the next line. First line with a backslash after.\\And the next line.First line with nothing after.And the next line. 强调（Emphasis）通过将文本设置为粗体或斜体来强调其重要性。 粗体（Bold）要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号（asterisks）。 Markdown HTML 渲染效果 I just love **bold text**. I just love &lt;strong&gt;bold text&lt;/strong&gt;. I just love bold text. I just love __bold text__. I just love &lt;strong&gt;bold text&lt;/strong&gt;. I just love bold text. Love**is**bold Love&lt;strong&gt;is&lt;/strong&gt;bold Loveisbold 粗体（Bold）用法最佳实践Markdown 应用程序在如何处理单词或短语中间的下划线上并不一致。为兼容考虑，在单词或短语中间部分加粗的话，请使用星号（asterisks）。 ✅ 这样做 ❌ 不要这样做 Love**is**bold Love__is__bold 斜体（Italic）要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）。要斜体突出单词的中间部分，请在字母前后各添加一个星号，中间不要带空格。 Markdown HTML 渲染效果 Italicized text is the *cat's meow*. Italicized text is the &lt;em&gt;cat's meow&lt;/em&gt;. Italicized text is the cat’s meow. Italicized text is the _cat's meow_. Italicized text is the &lt;em&gt;cat's meow&lt;/em&gt;. Italicized text is the cat’s meow. A*cat*meow A&lt;em&gt;cat&lt;/em&gt;meow Acatmeow 斜体（Italic）用法的最佳实践Markdown 的众多应用程序在如何处理单词中间的下划线上意见不一致。为了兼容起见，请用星号标注单词中间的斜体来表示着重。 ✅ 这样做 ❌ 不要这样做 A*cat*meow A_cat_meow 粗体（Bold）和斜体（Italic）要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。 Markdown HTML 渲染效果 This text is ***really important***. This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;. This text is really important\\. This text is ___really important___. This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;. This text is really important\\. This text is __*really important*__. This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;. This text is really important\\. This text is **_really important_**. This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;. This text is really important\\. This is really***very***important text. This is really&lt;strong&gt;&lt;em&gt;very&lt;/em&gt;&lt;/strong&gt;important text. This is really*very*important text. 粗体（Bold）和斜体（Italic）用法的最佳实践Markdown 应用程序在处理单词或短语中间添加的下划线上并不一致。为了实现兼容性，请使用星号将单词或短语的中间部分加粗并以斜体显示，以示重要。 ✅ 这样做 ❌ 不要这样做 This is really***very***important text. This is really___very___important text. 块引用（Blockquotes）要创建块引用，请在段落前添加一个 &gt; 符号。 1&gt; Dorothy followed her through many of the beautiful rooms in her castle. 渲染效果如下所示： Dorothy followed her through many of the beautiful rooms in her castle. 多个段落的块引用（Blockquotes）块引用可以包含多个段落。为段落之间的空白行各添加一个 &gt; 符号。 123&gt; Dorothy followed her through many of the beautiful rooms in her castle.&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood. 渲染效果如下： Dorothy followed her through many of the beautiful rooms in her castle. The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood. 嵌套块引用（Nested Blockquotes）块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。 123&gt; Dorothy followed her through many of the beautiful rooms in her castle.&gt;&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood. 渲染效果如下： Dorothy followed her through many of the beautiful rooms in her castle. The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood. 带有其它元素的块引用（Blockquotes with Other Elements）块引用可以包含其他 Markdown 格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。 123456&gt; #### The quarterly results look great!&gt;&gt; - Revenue was off the chart.&gt; - Profits were higher than ever.&gt;&gt; *Everything* is going according to **plan**. 渲染效果如下： The quarterly results look great! Revenue was off the chart. Profits were higher than ever. Everything is going according to plan. 列表（Lists）你可以将多个条目组织成有序或无序列表。 有序列表（Ordered Lists）要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。 Markdown HTML Rendered Output 1. First item2. Second item3. Third item4. Fourth item &lt;ol&gt;&lt;li&gt;First item&lt;/li&gt;&lt;li&gt;Second item&lt;/li&gt;&lt;li&gt;Third item&lt;/li&gt;&lt;li&gt;Fourth item&lt;/li&gt;&lt;/ol&gt; First itemSecond itemThird itemFourth item 1. First item1. Second item1. Third item1. Fourth item &lt;ol&gt;&lt;li&gt;First item&lt;/li&gt;&lt;li&gt;Second item&lt;/li&gt;&lt;li&gt;Third item&lt;/li&gt;&lt;li&gt;Fourth item&lt;/li&gt;&lt;/ol&gt; First itemSecond itemThird itemFourth item 1. First item8. Second item3. Third item5. Fourth item &lt;ol&gt;&lt;li&gt;First item&lt;/li&gt;&lt;li&gt;Second item&lt;/li&gt;&lt;li&gt;Third item&lt;/li&gt;&lt;li&gt;Fourth item&lt;/li&gt;&lt;/ol&gt; First itemSecond itemThird itemFourth item 1. First item2. Second item3. Third item 1. Indented item 2. Indented item4. Fourth item &lt;ol&gt;&lt;li&gt;First item&lt;/li&gt;&lt;li&gt;Second item&lt;/li&gt;&lt;li&gt;Third item&lt;ol&gt;&lt;li&gt;Indented item&lt;/li&gt;&lt;li&gt;Indented item&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;Fourth item&lt;/li&gt;&lt;/ol&gt; First itemSecond itemThird itemIndented itemIndented itemFourth item 有序列表（Ordered List）用法的最佳实践CommonMark 和其它几种轻量级标记语言可以让你使用括号（)）作为分隔符（例如 1) First item），但并非所有的 Markdown 应用程序都支持此种用法，因此，从兼容的角度来看，此用法不推荐。为了兼容起见，请只使用英文句点作为分隔符。 ✅ 这样做 ❌ 不要这样做 1. First item2. Second item 1) First item2) Second item 无序列表（Unordered Lists）要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。 Markdown HTML 渲染效果 - First item- Second item- Third item- Fourth item &lt;ul&gt;&lt;li&gt;First item&lt;/li&gt;&lt;li&gt;Second item&lt;/li&gt;&lt;li&gt;Third item&lt;/li&gt;&lt;li&gt;Fourth item&lt;/li&gt;&lt;/ul&gt; First itemSecond itemThird itemFourth item * First item* Second item* Third item* Fourth item &lt;ul&gt;&lt;li&gt;First item&lt;/li&gt;&lt;li&gt;Second item&lt;/li&gt;&lt;li&gt;Third item&lt;/li&gt;&lt;li&gt;Fourth item&lt;/li&gt;&lt;/ul&gt; First itemSecond itemThird itemFourth item + First item+ Second item+ Third item+ Fourth item &lt;ul&gt;&lt;li&gt;First item&lt;/li&gt;&lt;li&gt;Second item&lt;/li&gt;&lt;li&gt;Third item&lt;/li&gt;&lt;li&gt;Fourth item&lt;/li&gt;&lt;/ul&gt; First itemSecond itemThird itemFourth item - First item- Second item- Third item - Indented item - Indented item- Fourth item &lt;ul&gt;&lt;li&gt;First item&lt;/li&gt;&lt;li&gt;Second item&lt;/li&gt;&lt;li&gt;Third item&lt;ul&gt;&lt;li&gt;Indented item&lt;/li&gt;&lt;li&gt;Indented item&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Fourth item&lt;/li&gt;&lt;/ul&gt; First itemSecond itemThird itemIndented itemIndented itemFourth item 无序列表（Unordered List）用法的最佳实践Markdown 应用程序在如何处理同一列表中混用不同分隔符上并不一致。为了兼容起见，请不要在同一个列表中混用不同的分隔符，最好选定一种分隔符并一直用下去。 ✅ 这样做 ❌ 不要这样做 - First item- Second item- Third item- Fourth item + First item* Second item- Third item+ Fourth item 在列表中添加列表项要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符，如下例所示： 段落（Paragraphs）123456* This is the first list item.* Here's the second list item. I need to add another paragraph below the second list item.* And here's the third list item. 渲染效果如下： This is the first list item. Here’s the second list item. I need to add another paragraph below the second list item. And here’s the third list item. 引用块（Blockquotes）123456* This is the first list item.* Here's the second list item. &gt; A blockquote would look great below the second list item.* And here's the third list item. 渲染效果如下： This is the first list item. Here’s the second list item. A blockquote would look great below the second list item. And here’s the third list item. 代码块（Code Blocks）代码块（Code blocks） 通常采用四个空格或一个制表符缩进。当它们被放在列表中时，请将它们缩进八个空格或两个制表符。 1234567891. Open the file.2. Find the following code block on line 21: &lt;html&gt; &lt;head&gt; &lt;title&gt;Test&lt;/title&gt; &lt;/head&gt;3. Update the title to match the name of your website. 渲染效果如下： Open the file. Find the following code block on line 21: 1234&lt;html&gt; &lt;head&gt; &lt;title&gt;Test&lt;/title&gt; &lt;/head&gt; Update the title to match the name of your website. 图片（Images）1234561. Open the file containing the Linux mascot.2. Marvel at its beauty. ![Tux, the Linux mascot](/assets/images/tux.png)3. Close the file. 渲染效果如下： Open the file containing the Linux mascot. Marvel at its beauty. Close the file. 列表（Lists）你可以将无序列表嵌套在有序列表中，反之亦然。 1234561. First item2. Second item3. Third item - Indented item - Indented item4. Fourth item 渲染效果如下： First item Second item Third item Indented item Indented item Fourth item 代码要将单词或短语表示为代码，请将其包裹在反引号 (```) 中。 Markdown HTML 渲染效果 At the command prompt, type nano. At the command prompt, type &lt;code&gt;nano&lt;/code&gt;. At the command prompt, type nano. 转义反引号如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号(````)中。 Markdown HTML 渲染效果 Use `code` in your Markdown file. &lt;code&gt;Use code in your Markdown file.&lt;/code&gt; Use code in your Markdown file. 代码块（Code Blocks）要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符。 1234&lt;html&gt; &lt;head&gt; &lt;/head&gt;&lt;/html&gt; 渲染效果如下： 1234&lt;html&gt; &lt;head&gt; &lt;/head&gt;&lt;/html&gt; 注意： 要创建不用缩进的代码块，请使用 围栏式代码块（fenced code blocks）. 分隔线（Horizontal Rules）要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (---) 或下划线 (___) ，并且不能包含其他内容。 12345***---_________________ 以上三个分隔线的渲染效果看起来都一样： 分隔线（Horizontal Rule）用法最佳实践为了兼容性，请在分隔线的前后均添加空白行。 ✅ 这样做 ❌ 不要这样做 Try to put a blank line before...---...and after a horizontal rule. Without blank lines, this would be a heading.---Don't do this! 链接（Links）要创建链接，请将链接文本括在方括号（例如 [Duck Duck Go]）中，后面紧跟着括在圆括号中的 URL（例如 (https://duckduckgo.com) ）。 1My favorite search engine is [Duck Duck Go](https://duckduckgo.com). 渲染效果如下： My favorite search engine is Duck Duck Go. 添加标题你可以选择为链接添加标题（即 title 属性）。当用户将鼠标悬停在链接上时，将显示一个提示。要添加标题，请将其放在 URL 后面。 1My favorite search engine is [Duck Duck Go](https://duckduckgo.com &quot;The best search engine for privacy&quot;). 渲染效果如下： My favorite search engine is Duck Duck Go. 网址和电子邮件地址要将 URL 或电子邮件地址快速转换为链接，请将其括在尖括号中。 12&lt;https://www.markdownguide.org&gt;&lt;fake@example.com&gt; 渲染效果如下： https://www.markdownguide.orgfake@example.com 格式化链接如需 强调（emphasize） 某个链接, 请在方括号前及圆括号后添加星号。要将链接表示为 代码（code） ，请在方括号内添加反引号。 123I love supporting the **[EFF](https://eff.org)**.This is the *[Markdown Guide](https://www.markdownguide.org)*.See the section on [`code`](#code). 渲染效果如下： I love supporting the EFF.This is the Markdown Guide.See the section on code. 引用式链接引用式（Reference-style）链接是一种特殊类型的链接，它使得 URL 在 Markdown 中更易于显示和阅读。引用式链接由两部分组成：一部分被放置在正文文本中；另一部分被放置在文档中的其它地方，以便于阅读。 引用式链接第一部分的格式引用式链接的第一部分的格式由两组方括号组成。第一组方括号内放的是显示为链接的文本，第二组方括号内放的是一个标签，该标签用于指向您存放在文档中其它位置的链接。 尽管不是必须的，但你可以在第一组和第二组方括号之间添加一个空格。第二组方括号中的标签不区分大小写，并且可以包含字母、数字、空格或标点符号。 以下示例中，链接的第一部分是等效的： [hobbit-hole][1] [hobbit-hole] [1] 引用式链接第二部分的格式引用式链接的第二部分可以包含以下属性： 放在方括号内的标签，以及紧跟在方括号后面的一个冒号和至少一个空格（例如 [label]: ）。 链接的 URL，可以选择将其括在尖括号内。 链接的标题（可有可无），可以将其括在双引号、单引号或括号内。 以下示例中，链接的第二部分是等效的： [1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle [1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle &quot;Hobbit lifestyles&quot; [1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle 'Hobbit lifestyles' [1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle (Hobbit lifestyles) [1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; &quot;Hobbit lifestyles&quot; [1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; 'Hobbit lifestyles' [1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; (Hobbit lifestyles) 可以将链接的第二部分放在 Markdown 文档中的任何位置。有些人将它们放在被引用的段落的后面，有些人将它们放在文档的末尾（类似尾注或脚注）。 将两部分组合在一起使用的示例假设你将一个 URL 作为一个 标准 URL 链接 添加到段落中，在 Markdown 中如下所示： 123In a hole in the ground there lived a hobbit. Not a nasty, dirty, wet hole, filled with the endsof worms and an oozy smell, nor yet a dry, bare, sandy hole with nothing in it to sit down on or toeat: it was a [hobbit-hole](https://en.wikipedia.org/wiki/Hobbit#Lifestyle &quot;Hobbit lifestyles&quot;), and that means comfort. Though it may point to interesting additional information, the URL as displayed really doesn’t add much to the existing raw text other than making it harder to read. To fix that, you could format the URL like this instead: 12345In a hole in the ground there lived a hobbit. Not a nasty, dirty, wet hole, filled with the endsof worms and an oozy smell, nor yet a dry, bare, sandy hole with nothing in it to sit down on or toeat: it was a [hobbit-hole][1], and that means comfort.[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; &quot;Hobbit lifestyles&quot; 在上述两个实例中，渲染后的输出是相同的： In a hole in the ground there lived a hobbit. Not a nasty, dirty, wet hole, filled with the ends of worms and an oozy smell, nor yet a dry, bare, sandy hole with nothing in it to sit down on or to eat: it was a hobbit-hole, and that means comfort. 该链接的 HTML 为： 1&lt;a href=&quot;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&quot; title=&quot;Hobbit lifestyles&quot;&gt;hobbit-hole&lt;/a&gt; 链接（Link）的最佳使用实践不同的 Markdown 应用程序在处理 URL 中间的空格方面是不一样的。为了兼容起见，请尽量使用 %20 （空格的编码形式）来代替空格。 ✅ 这样做 ❌ 不要这样做 [link](https://www.example.com/my%20great%20page) [link](https://www.example.com/my great page) 图片（Images）要添加图片，首先请添加感叹号（!），然后紧跟着是方括号，方括号中可添加替代文本（alt text，即图片显示失败后显示此文本），最后跟着圆括号，圆括号中添加图片资源的路径或 URL。你可以选择在圆括号中的 URL 之后添加标题（即 title 属性）。 1![Philadelphia's Magic Gardens. This place was so cool!](/assets/images/philly-magic-gardens.jpg &quot;Philadelphia's Magic Gardens&quot;) 渲染效果如下： 带链接的图片要为图片添加链接，请先为图片的 Markdown 标记添加一个方括号，然后紧跟着一个圆括号，并在圆括号中添加链接地址。 1[![An old rock in the desert](/assets/images/shiprock.jpg &quot;Shiprock, New Mexico by Beau Rogers&quot;)](https://www.flickr.com/photos/beaurogers/31833779864/in/photolist-Qv3rFw-34mt9F-a9Cmfy-5Ha3Zi-9msKdv-o3hgjr-hWpUte-4WMsJ1-KUQ8N-deshUb-vssBD-6CQci6-8AFCiD-zsJWT-nNfsgB-dPDwZJ-bn9JGn-5HtSXY-6CUhAL-a4UTXB-ugPum-KUPSo-fBLNm-6CUmpy-4WMsc9-8a7D3T-83KJev-6CQ2bK-nNusHJ-a78rQH-nw3NvT-7aq2qf-8wwBso-3nNceh-ugSKP-4mh4kh-bbeeqH-a7biME-q3PtTf-brFpgb-cg38zw-bXMZc-nJPELD-f58Lmo-bXMYG-bz8AAi-bxNtNT-bXMYi-bXMY6-bXMYv) 渲染效果如下： 转义字符（Escaping Characters）要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 (\\) 。 1\\* 如果没有开头的反斜杠字符的话，这一行将显示为无序列表。 渲染效果如下： * 如果没有开头的反斜杠字符的话，这一行将显示为无序列表。 可做转义的（英文）字符以下列出的字符都可以通过使用反斜杠字符从而达到转义目的。 字符 名称 \\ 反斜杠（backslash） ` backtick (另请参见 在代码中转义反引号) * 星号（asterisk） _ 下划线（underscore） { } 花括号（curly braces） [ ] 方括号（brackets） &lt; &gt; angle brackets ( ) 圆括号或括号（parentheses） # 井号（pound sign） + 加号（plus sign） - 减号（minus sign） (也叫连字符 hyphen) . 句点（dot） ! 感叹号（exclamation mark） | 管道符（pipe） (另请参见 在表格中转义管道符) HTML 标签大多 Markdown 应用程序允许你在 Markdown 格式文本中添加 HTML 标签。如果你喜欢某些 HTML 标签胜于 Markdown 语法的话，这将何有帮助。例如，某些人发现通过 HTML 标签添加图像更加容易。当你需要更改元素的属性时（例如为文本指定颜色或更改图像的宽度），使用 HTML 标签更方便些。 如需使用 HTML，请将 HTML 标签添加到 Markdown 格式文本中即可。 1This **word** is bold. This &lt;em&gt;word&lt;/em&gt; is italic. 渲染效果如下： This word is bold. This word is italic. HTML 用法最佳实践出于安全原因，并非所有 Markdown 应用程序都支持在 Markdown 文档中添加 HTML。如有疑问，请查看 Markdown 应用程序的文档。某些应用程序只支持 HTML 标签的子集。 对于 HTML 的块级元素 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt; 和 &lt;p&gt;，请在其前后使用空行（blank lines）与其它内容进行分隔。尽量不要使用制表符（tabs）或空格（spaces）对 HTML 标签做缩进，否则将影响格式。 在 HTML 块级标签内不能使用 Markdown 语法。例如 &lt;p&gt;italic and **bold**&lt;/p&gt; 将不起作用。","link":"/2021/02/02/markdown%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"go入门","slug":"go入门","link":"/tags/go%E5%85%A5%E9%97%A8/"},{"name":"hexo踩坑","slug":"hexo踩坑","link":"/tags/hexo%E8%B8%A9%E5%9D%91/"},{"name":"奇技淫巧","slug":"奇技淫巧","link":"/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}],"categories":[]}